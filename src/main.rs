use std::collections::HashMap;
use std::env::args;
use std::fs::{copy, create_dir_all, File};
use std::io::{BufRead, BufReader};

use anyhow::{Context, Result};
use chrono::Local;
use getopts::Options;
use log::{info, warn};
use rand::distributions::{Alphanumeric, DistString};
use rand::thread_rng;
use regex::Regex;
use tokio::time::{timeout, Duration};
use uuid::Uuid;

use malware_analysis_sandbox::log::{ExecutionLog, LogManager};
use malware_analysis_sandbox::sysmon_event::{SysmonEvent, SysmonEventId};
use malware_analysis_sandbox::vm::Vm;

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();

    let mut opts = Options::new();
    opts.optopt("", "path", "target program", "FILE");
    opts.optopt("", "id", "analysis id", "");

    let arg = args().collect::<Vec<String>>();

    let matches = opts.parse(&arg[1..])?;

    let log_manager = LogManager::init().await?;

    let analysis_id;
    match matches.opt_str("id") {
        Some(id) => {
            if let Some(_) = matches.opt_str("path") {
                warn!("path option was ignored because id is specified");
            }
            if !log_manager.is_exist(&id).await? {
                panic!("id does not exists");
            }
            analysis_id = id;
        }
        None => {
            let program_path = matches
                .opt_str("path")
                .expect("Either path or id is required");
            analysis_id = Uuid::new_v4().to_string();
            let analysis_path = format!("working_dir/{}/", analysis_id);
            create_dir_all(analysis_path.clone() + "sample")?;
            copy(program_path, analysis_path.clone() + "sample/program")?;
            create_dir_all(analysis_path + "artifact")?;
        }
    }
    let program_path = format!("working_dir/{}/sample/program", analysis_id);

    let exec_limit_time = 1;

    let container_name =
        "sandbox-".to_string() + &Alphanumeric.sample_string(&mut thread_rng(), 16);

    info!("Creating vm {}...", container_name);
    let vm = Vm::create(&container_name, "sandbox").await?;

    info!("Pushing sysmon config file...");
    vm.push_file("config.xml", "/root/config.xml").await?;

    info!("Pushing target program...");
    vm.push_file(program_path, "/home/ubuntu/program").await?;

    info!("Starting sysmon...");
    vm.exec(&["sysmon", "-accepteula", "-i", "/root/config.xml"])
        .await?;

    info!("Starting target program...");
    match timeout(
        Duration::from_secs(exec_limit_time),
        vm.exec(&["sudo", "-u", "ubuntu", "/home/ubuntu/program"]),
    )
    .await
    {
        Err(_) => warn!(
            "Target program was forcefully terminated because it didn't finish within {}s",
            exec_limit_time
        ),
        Ok(_) => info!("Finished"),
    }

    info!("Pulling syslog...");
    let syslog_path = format!("working_dir/{}/artifact/syslog", analysis_id);
    vm.pull_file("/var/log/syslog", &syslog_path).await?;

    info!("Analyzing syslog...");
    let syslog = File::open(syslog_path)?;
    let re = Regex::new(r"[A-Z][a-z]{2}\s+\d+\s\d\d:\d\d:\d\d\s\S+\ssysmon\S*:\s(.+)").unwrap();

    let mut created_files = HashMap::new();
    let mut sysmon_events = Vec::new();
    for l in BufReader::new(syslog).lines() {
        if let Some(c) = re.captures(&l?) {
            if let Ok(event) = SysmonEvent::from_xml(&c[1]) {
                if event.event_id == SysmonEventId::FILE_CREATE {
                    let file_name = event
                        .event_data
                        .get("TargetFilename")
                        .context("No TargetFilename attribute")?;
                    if !created_files.contains_key(file_name) {
                        created_files.insert(
                            file_name.to_string(),
                            Alphanumeric.sample_string(&mut thread_rng(), 16),
                        );
                    }
                }

                sysmon_events.push(event);
            }
        };
    }

    info!("Pulling created files...");
    for f in &created_files {
        let _ = vm.pull_file(f.0, format!("artifact/{}", f.1));
    }

    info!("Recording to mongodb...");
    let execution_log = ExecutionLog {
        time: Local::now(),
        sysmon_events,
        created_files,
    };

    log_manager
        .store_execution_log(analysis_id, execution_log)
        .await?;

    Ok(())
}
