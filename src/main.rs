use std::collections::HashMap;
use std::fs;
use std::fs::{create_dir_all, File};
use std::io;
use std::io::{BufRead, BufReader};

use anyhow::{Context, Result};
use chrono::Local;
use clap::Parser;
use log::{info, warn};
use regex::Regex;
use sha3::{Digest, Sha3_512};
use tokio::time::{timeout, Duration};
use uuid::Uuid;

use malware_analysis_sandbox::analysis_result::{AnalysisResultManager, ExecutionLog};
use malware_analysis_sandbox::args::Args;
use malware_analysis_sandbox::sysmon_event::{SysmonEvent, SysmonEventId};
use malware_analysis_sandbox::vm::Vm;

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();

    let args = Args::parse();

    let mut sample = File::open(&args.path)?;

    info!("Calcurating hash of sample...");
    let mut hasher = Sha3_512::new();
    io::copy(&mut sample, &mut hasher)?;
    let hash = format!("{:x}", hasher.finalize());

    let analysis_result_manager = AnalysisResultManager::init().await?;

    info!("Searching result...");
    let analysis_result = analysis_result_manager.search_hash(&hash).await?;

    let id;
    match analysis_result {
        Some(r) => {
            if !args.re_analyze && !r.execution_logs.is_empty() {
                warn!("The sample was already analyzed");
                warn!("If you want to re-analyze, please run with --re-analyze option");
                return Ok(());
            }
            id = r.id;
        }
        None => {
            id = Uuid::new_v4().to_string();
            analysis_result_manager.make_new_result(&id, &hash).await?;
            create_dir_all(format!("analysis_result/{}/sample", &id))?;
            create_dir_all(format!("analysis_result/{}/artifact", &id))?;
            fs::copy(args.path, format!("analysis_result/{}/sample/sample", &id))?;
        }
    }

    let execution_id = Uuid::new_v4().to_string();
    let artifact_dir = format!("analysis_result/{}/artifact/{}", &id, &execution_id);
    create_dir_all(&artifact_dir)?;

    let sample_path = format!("analysis_result/{}/sample/sample", id);

    let exec_limit_time = 1;

    let container_name = "sandbox-".to_string() + &id;

    info!("Creating vm {}...", container_name);
    let vm = Vm::create(&container_name, "sandbox").await?;

    info!("Pushing sysmon config file...");
    vm.push_file("config.xml", "/root/config.xml").await?;

    info!("Pushing sample...");
    vm.push_file(sample_path, "/home/ubuntu/sample").await?;

    info!("Starting sysmon...");
    vm.exec(&["sysmon", "-accepteula", "-i", "/root/config.xml"])
        .await?;

    info!("Executing sample...");
    match timeout(
        Duration::from_secs(exec_limit_time),
        vm.exec(&["sudo", "-u", "ubuntu", "/home/ubuntu/sample"]),
    )
    .await
    {
        Err(_) => warn!(
            "Target program was forcefully terminated because it didn't finish within {}s",
            exec_limit_time
        ),
        Ok(_) => info!("Finished"),
    }

    info!("Pulling syslog...");
    let syslog_path = format!("{}/syslog", &artifact_dir);
    vm.pull_file("/var/log/syslog", &syslog_path).await?;

    info!("Analyzing syslog...");
    let syslog = File::open(syslog_path)?;
    let re = Regex::new(r"[A-Z][a-z]{2}\s+\d+\s\d\d:\d\d:\d\d\s\S+\ssysmon\S*:\s(.+)").unwrap();

    let mut created_files = HashMap::new();
    let mut sysmon_events = Vec::new();
    for l in BufReader::new(syslog).lines() {
        if let Some(c) = re.captures(&l?) {
            if let Ok(event) = SysmonEvent::from_xml(&c[1]) {
                if event.event_id == SysmonEventId::FILE_CREATE {
                    let file_name = event
                        .event_data
                        .get("TargetFilename")
                        .context("No TargetFilename attribute")?;
                    if !created_files.contains_key(file_name) {
                        created_files.insert(file_name.to_string(), Uuid::new_v4().to_string());
                    }
                }

                sysmon_events.push(event);
            }
        };
    }

    info!("Pulling created files...");
    for f in &created_files {
        let _ = vm
            .pull_file(f.0, format!("{}/{}", &artifact_dir, f.1))
            .await;
    }

    info!("Recording to mongodb...");
    let execution_log = ExecutionLog {
        id: execution_id,
        time: Local::now(),
        sysmon_events,
        created_files,
    };

    analysis_result_manager
        .store_execution_log(&id, execution_log)
        .await?;

    Ok(())
}
