mod sysmon_event;
mod vm;

use std::collections::HashMap;
use std::env::args;
use std::fs::{copy, create_dir_all, File};
use std::io::{BufRead, BufReader};

use anyhow::{Context, Result};
use chrono::{DateTime, Local};
use getopts::Options;
use log::{info, warn};
use mongodb::{
    bson::doc,
    options::{ClientOptions, ServerApi, ServerApiVersion},
    Client,
};
use rand::distributions::{Alphanumeric, DistString};
use rand::thread_rng;
use regex::Regex;
use serde::{Deserialize, Serialize};
use sysmon_event::{SysmonEvent, SysmonEventId};
use tokio::time::{timeout, Duration};
use uuid::Uuid;

use vm::Vm;

#[derive(Serialize, Deserialize, Debug)]
struct ExecutionLog {
    pub time: DateTime<Local>,
    pub sysmon_events: Vec<SysmonEvent>,
    pub created_files: HashMap<String, String>,
}

#[derive(Serialize, Deserialize, Debug)]
struct ProgramLog {
    pub id: String,
    pub execution_logs: Vec<ExecutionLog>,
}

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();

    let mut opts = Options::new();
    opts.optopt("", "path", "target program", "FILE");
    opts.optopt("", "id", "analysis id", "");

    let arg = args().collect::<Vec<String>>();

    let matches = opts.parse(&arg[1..])?;

    info!("Connecting mongodb...");
    let uri = "mongodb://localhost:27017";
    let mut client_options = ClientOptions::parse(uri).await?;

    let server_api = ServerApi::builder().version(ServerApiVersion::V1).build();
    client_options.server_api = Some(server_api);

    let client = Client::with_options(client_options)?;
    let collection = client
        .database("malware-analysis")
        .collection::<ProgramLog>("log");

    let analysis_id;
    let mut old_execution_logs = None;
    match matches.opt_str("id") {
        Some(id) => {
            if let Some(_) = matches.opt_str("path") {
                warn!("path option was ignored because id is specified");
            }
            old_execution_logs = Some(
                collection
                    .find_one(doc! {"id": &id}, None)
                    .await?
                    .expect("id not exists"),
            );
            analysis_id = id;
        }
        None => {
            let program_path = matches
                .opt_str("path")
                .expect("Either path or id is required");
            analysis_id = Uuid::new_v4().to_string();
            let analysis_path = format!("working_dir/{}/", analysis_id);
            create_dir_all(analysis_path.clone() + "sample")?;
            copy(program_path, analysis_path.clone() + "sample/program")?;
            create_dir_all(analysis_path + "artifact")?;
        }
    }
    let program_path = format!("working_dir/{}/sample/program", analysis_id);

    let exec_limit_time = 1;

    let container_name =
        "sandbox-".to_string() + &Alphanumeric.sample_string(&mut thread_rng(), 16);

    info!("Creating vm {}...", container_name);
    let vm = Vm::create(&container_name, "sandbox").await?;

    info!("Pushing sysmon config file...");
    vm.push_file("config.xml", "/root/config.xml").await?;

    info!("Pushing target program...");
    vm.push_file(program_path, "/home/ubuntu/program").await?;

    info!("Starting sysmon...");
    vm.exec(&["sysmon", "-accepteula", "-i", "/root/config.xml"])
        .await?;

    info!("Starting target program...");
    match timeout(
        Duration::from_secs(exec_limit_time),
        vm.exec(&["sudo", "-u", "ubuntu", "/home/ubuntu/program"]),
    )
    .await
    {
        Err(_) => warn!(
            "Target program was forcefully terminated because it didn't finish within {}s",
            exec_limit_time
        ),
        Ok(_) => info!("Finished"),
    }

    info!("Pulling syslog...");
    let syslog_path = format!("working_dir/{}/artifact/syslog", analysis_id);
    vm.pull_file("/var/log/syslog", &syslog_path).await?;

    info!("Analyzing syslog...");
    let syslog = File::open(syslog_path)?;
    let re = Regex::new(r"[A-Z][a-z]{2}\s+\d+\s\d\d:\d\d:\d\d\s\S+\ssysmon\S*:\s(.+)").unwrap();

    let mut created_files = HashMap::new();
    let mut sysmon_events = Vec::new();
    for l in BufReader::new(syslog).lines() {
        if let Some(c) = re.captures(&l?) {
            if let Ok(event) = SysmonEvent::from_xml(&c[1]) {
                if event.event_id == SysmonEventId::FILE_CREATE {
                    let file_name = event
                        .event_data
                        .get("TargetFilename")
                        .context("No TargetFilename attribute")?;
                    if !created_files.contains_key(file_name) {
                        created_files.insert(
                            file_name.to_string(),
                            Alphanumeric.sample_string(&mut thread_rng(), 16),
                        );
                    }
                }

                sysmon_events.push(event);
            }
        };
    }

    info!("Pulling created files...");
    for f in &created_files {
        let _ = vm.pull_file(f.0, format!("artifact/{}", f.1));
    }

    info!("Recording to mongodb...");
    let execution_log = ExecutionLog {
        time: Local::now(),
        sysmon_events,
        created_files,
    };

    let program_log;
    match old_execution_logs {
        Some(mut logs) => {
            collection
                .delete_one(doc! {"id": analysis_id.to_string()}, None)
                .await?;
            logs.execution_logs.push(execution_log);
            program_log = ProgramLog {
                id: analysis_id,
                execution_logs: logs.execution_logs,
            };
        }
        None => {
            program_log = ProgramLog {
                id: analysis_id,
                execution_logs: vec![execution_log],
            }
        }
    }

    collection.insert_one(program_log, None).await?;

    Ok(())
}
