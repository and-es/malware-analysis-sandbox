mod sysmon_event;
mod vm;

use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufReader, Write};

use anyhow::{Context, Result};
use log::{error, info, warn};
use rand::distributions::{Alphanumeric, DistString};
use rand::thread_rng;
use regex::Regex;
use sysmon_event::{SysmonEvent, SysmonEventId};
use tokio::time::{timeout, Duration};
use vm::Vm;

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();

    let exec_limit_time = 1;

    let container_name =
        "sandbox-".to_string() + &Alphanumeric.sample_string(&mut thread_rng(), 16);

    info!("Creating vm {}...", container_name);
    let vm = Vm::create(&container_name, "sandbox").await?;

    info!("Pushing sysmon config file...");
    vm.push_file("config.xml", "/root/config.xml").await?;

    info!("Pushing target program...");
    vm.push_file("loop.sh", "/home/ubuntu/loop.sh").await?;

    info!("Starting sysmon...");
    vm.exec(&["sysmon", "-accepteula", "-i", "/root/config.xml"])
        .await?;

    info!("Starting target program...");
    match timeout(
        Duration::from_secs(exec_limit_time),
        vm.exec(&["sudo", "-u", "ubuntu", "/home/ubuntu/loop.sh"]),
    )
    .await
    {
        Err(_) => warn!(
            "Target program was forcefully terminated because it didn't finish within {}s",
            exec_limit_time
        ),
        Ok(_) => info!("Finished"),
    }

    info!("Pulling syslog...");
    vm.pull_file("/var/log/syslog", "artifact").await?;

    info!("Extracting created file list...");
    let syslog = File::open("artifact/syslog")?;
    let re = Regex::new(r"[A-Z][a-z]{2}\s+\d+\s\d\d:\d\d:\d\d\s\S+\ssysmon\S*:\s(.+)").unwrap();
    let mut created_files = HashMap::new();
    for l in BufReader::new(syslog).lines() {
        if let Some(c) = re.captures(&l?) {
            if let Ok(event) = SysmonEvent::from_xml(&c[1]) {
                if event.event_id == SysmonEventId::FILE_CREATE {
                    let file_name = event
                        .event_data
                        .get("TargetFilename")
                        .context("No TargetFilename attribute")?;
                    if !created_files.contains_key(file_name) {
                        created_files.insert(
                            file_name.to_string(),
                            Alphanumeric.sample_string(&mut thread_rng(), 16),
                        );
                    }
                }
            }
        };
    }

    info!("Exporting created file list...");
    let mut json = File::create("artifact/created_file.json")?;
    json.write_all(serde_json::to_string(&created_files)?.as_bytes())?;

    info!("Pulling created files...");
    for f in created_files {
        let _ = vm.pull_file(f.0, format!("artifact/{}", f.1));
    }

    Ok(())
}
