use std::path::Path;
use std::process::Command;

use anyhow::{anyhow, Context, Result};

fn lxc(args: &[&str]) -> Result<Vec<u8>> {
    let mut cmd = Command::new("lxc");
    for arg in args.iter() {
        cmd.arg(arg);
    }

    let output = cmd.output()?;
    if output.status.success() {
        Ok(output.stdout)
    } else {
        Err(anyhow!(
            "LXD {:?} failed with {}: {:?}",
            args,
            output.status,
            String::from_utf8_lossy(&output.stderr)
        ))
    }
}

pub struct Vm {
    name: String,
}

impl Vm {
    pub fn new(name: &str, base: &str) -> Result<Self> {
        lxc(&["launch", base, name, "-e"])?;

        Ok(Vm {
            name: name.to_string(),
        })
    }

    fn can_access(&self) -> bool {
        lxc(&[
            "exec",
            &self.name,
            "--mode=non-interactive",
            "-n",
            "--",
            "touch",
            "/etc/fstab",
        ])
        .is_ok()
    }

    pub fn wait_for_starting(&self) {
        loop {
            if self.can_access() {
                break;
            }
        }
    }

    pub fn exec(&self, command: &[&str]) -> Result<String> {
        let mut args = vec!["exec", &self.name, "--"];
        for arg in command.as_ref().iter() {
            args.push(arg.as_ref());
        }
        Ok(String::from_utf8_lossy(&lxc(&args)?).into_owned())
    }

    fn instance_path<P: AsRef<Path>>(&self, path: P) -> Result<String> {
        let path_with_no_root = if path.as_ref().has_root() {
            path.as_ref().strip_prefix("/")?
        } else {
            path.as_ref()
        };
        Ok(format!("{}/{}", self.name, path_with_no_root.display()))
    }

    fn pull<T: AsRef<Path>, U: AsRef<Path>>(
        &self,
        source: T,
        dest: U,
        recursive: bool,
    ) -> Result<()> {
        let instance_path = self.instance_path(source)?;
        let mut args = vec![
            "file",
            "pull",
            "-p",
            "-q",
            &instance_path,
            dest.as_ref()
                .to_str()
                .context("dest must be valid unicode")?,
        ];
        if recursive {
            args.push("-r");
        }

        lxc(&args)?;
        Ok(())
    }

    pub fn pull_file<T: AsRef<Path>, U: AsRef<Path>>(&self, source: T, dest: U) -> Result<()> {
        self.pull(source, dest, false)
    }

    pub fn pull_dir<T: AsRef<Path>, U: AsRef<Path>>(&self, source: T, dest: U) -> Result<()> {
        self.pull(source, dest, true)
    }

    fn push<T: AsRef<Path>, U: AsRef<Path>>(
        &self,
        source: T,
        dest: U,
        recursive: bool,
    ) -> Result<()> {
        let instance_path = self.instance_path(dest)?;
        let mut args = vec![
            "file",
            "push",
            "-p",
            "-q",
            source
                .as_ref()
                .to_str()
                .context("dest must be valid unicode")?,
            &instance_path,
        ];
        if recursive {
            args.push("-r");
        }

        lxc(&args)?;
        Ok(())
    }

    pub fn push_file<T: AsRef<Path>, U: AsRef<Path>>(&self, source: T, dest: U) -> Result<()> {
        self.push(source, dest, false)
    }

    pub fn push_dir<T: AsRef<Path>, U: AsRef<Path>>(&self, source: T, dest: U) -> Result<()> {
        self.push(source, dest, true)
    }
}

impl Drop for Vm {
    fn drop(&mut self) {
        let _ = lxc(&["stop", &self.name, "-f"]);
    }
}
