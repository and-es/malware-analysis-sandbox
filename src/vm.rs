use std::path::Path;

use anyhow::{anyhow, Context, Result};
use tokio::process::Command;

async fn lxc(args: &[&str]) -> Result<Vec<u8>> {
    let mut cmd = Command::new("lxc");
    for arg in args.iter() {
        cmd.arg(arg);
    }

    let output = cmd.output().await?;
    if output.status.success() {
        Ok(output.stdout)
    } else {
        Err(anyhow!(
            "LXD {:?} failed with {}: {:?}",
            args,
            output.status,
            String::from_utf8_lossy(&output.stderr)
        ))
    }
}

pub struct Vm {
    name: String,
}

impl Vm {
    pub async fn create(name: &str, base: &str) -> Result<Self> {
        lxc(&["launch", base, name, "-e"]).await?;

        loop {
            let can_access = lxc(&[
                "exec",
                name,
                "--mode=non-interactive",
                "-n",
                "--",
                "touch",
                "/etc/fstab",
            ])
            .await
            .is_ok();

            if can_access {
                break;
            }
        }

        Ok(Vm {
            name: name.to_string(),
        })
    }

    pub async fn exec(&self, command: &[&str]) -> Result<String> {
        let mut args = vec!["exec", &self.name, "--"];
        for arg in command.as_ref().iter() {
            args.push(arg.as_ref());
        }
        Ok(String::from_utf8_lossy(&lxc(&args).await?).into_owned())
    }

    fn instance_path<P: AsRef<Path>>(&self, path: P) -> Result<String> {
        let path_with_no_root = if path.as_ref().has_root() {
            path.as_ref().strip_prefix("/")?
        } else {
            path.as_ref()
        };
        Ok(format!("{}/{}", self.name, path_with_no_root.display()))
    }

    async fn pull<T: AsRef<Path>, U: AsRef<Path>>(
        &self,
        source: T,
        dest: U,
        recursive: bool,
    ) -> Result<()> {
        let instance_path = self.instance_path(source)?;
        let mut args = vec![
            "file",
            "pull",
            "-p",
            "-q",
            &instance_path,
            dest.as_ref()
                .to_str()
                .context("dest must be valid unicode")?,
        ];
        if recursive {
            args.push("-r");
        }

        lxc(&args).await?;
        Ok(())
    }

    pub async fn pull_file<T: AsRef<Path>, U: AsRef<Path>>(
        &self,
        source: T,
        dest: U,
    ) -> Result<()> {
        self.pull(source, dest, false).await
    }

    pub async fn pull_dir<T: AsRef<Path>, U: AsRef<Path>>(&self, source: T, dest: U) -> Result<()> {
        self.pull(source, dest, true).await
    }

    async fn push<T: AsRef<Path>, U: AsRef<Path>>(
        &self,
        source: T,
        dest: U,
        recursive: bool,
    ) -> Result<()> {
        let instance_path = self.instance_path(dest)?;
        let mut args = vec![
            "file",
            "push",
            "-p",
            "-q",
            source
                .as_ref()
                .to_str()
                .context("dest must be valid unicode")?,
            &instance_path,
        ];
        if recursive {
            args.push("-r");
        }

        lxc(&args).await?;
        Ok(())
    }

    pub async fn push_file<T: AsRef<Path>, U: AsRef<Path>>(
        &self,
        source: T,
        dest: U,
    ) -> Result<()> {
        self.push(source, dest, false).await
    }

    pub async fn push_dir<T: AsRef<Path>, U: AsRef<Path>>(&self, source: T, dest: U) -> Result<()> {
        self.push(source, dest, true).await
    }
}

impl Drop for Vm {
    fn drop(&mut self) {
        let _ = lxc(&["stop", &self.name, "-f"]);
    }
}
