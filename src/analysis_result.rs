use std::collections::HashMap;

use anyhow::{Context, Result};
use chrono::{DateTime, Local};
use log::info;
use mongodb::bson::{doc, Document};
use mongodb::options::{ClientOptions, ServerApi, ServerApiVersion};
use mongodb::{Client, Collection};
use serde::{Deserialize, Serialize};

use crate::sysmon_event::SysmonEvent;

#[derive(Serialize, Deserialize, Debug)]
pub struct ExecutionLog {
    pub id: String,
    pub time: DateTime<Local>,
    pub sysmon_events: Vec<SysmonEvent>,
    pub created_files: HashMap<String, String>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct AnalysisResult {
    pub id: String,
    pub hash: String,
    pub execution_logs: Vec<ExecutionLog>,
}

pub struct AnalysisResultManager {
    collection: Collection<AnalysisResult>,
}

impl AnalysisResultManager {
    pub async fn init() -> Result<AnalysisResultManager> {
        info!("Connecting mongodb...");
        let uri = "mongodb://localhost:27017";
        let mut client_options = ClientOptions::parse(uri).await?;

        let server_api = ServerApi::builder().version(ServerApiVersion::V1).build();
        client_options.server_api = Some(server_api);

        let client = Client::with_options(client_options)?;
        let collection = client
            .database("malware-analysis")
            .collection::<AnalysisResult>("result");

        Ok(AnalysisResultManager { collection })
    }

    async fn find_one(
        &self,
        filter: impl Into<Option<Document>>,
    ) -> Result<Option<AnalysisResult>> {
        Ok(self.collection.find_one(filter, None).await?)
    }

    pub async fn search_hash(&self, hash: &str) -> Result<Option<AnalysisResult>> {
        self.find_one(doc! {"hash": hash}).await
    }

    async fn get(&self, id: &str) -> Result<Option<AnalysisResult>> {
        self.find_one(doc! {"id": id}).await
    }

    async fn delete(&self, id: &str) -> Result<()> {
        self.collection.delete_one(doc! {"id": &id}, None).await?;
        Ok(())
    }

    pub async fn is_exist(&self, id: &str) -> Result<bool> {
        match self.get(id).await? {
            Some(_) => Ok(true),
            None => Ok(false),
        }
    }

    pub async fn make_new_result(&self, id: &str, hash: &str) -> Result<()> {
        let analysis_result = AnalysisResult {
            id: id.to_string(),
            hash: hash.to_string(),
            execution_logs: Vec::new(),
        };
        self.collection.insert_one(analysis_result, None).await?;

        Ok(())
    }

    pub async fn store_execution_log(&self, id: &str, execution_log: ExecutionLog) -> Result<()> {
        let mut prev_analysis_result = self
            .get(&id)
            .await?
            .context("No analysis result for the id")?;
        self.delete(&id).await?;
        prev_analysis_result.execution_logs.push(execution_log);
        let new_analysis_result = AnalysisResult {
            id: id.to_string(),
            hash: prev_analysis_result.hash,
            execution_logs: prev_analysis_result.execution_logs,
        };

        self.collection
            .insert_one(new_analysis_result, None)
            .await?;

        Ok(())
    }
}
