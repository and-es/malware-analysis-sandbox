use std::collections::HashMap;

use anyhow::Result;
use chrono::{DateTime, Local};
use log::info;
use mongodb::{
    bson::doc,
    options::{ClientOptions, ServerApi, ServerApiVersion},
    Client, Collection,
};
use serde::{Deserialize, Serialize};

use crate::sysmon_event::SysmonEvent;

#[derive(Serialize, Deserialize, Debug)]
pub struct ExecutionLog {
    pub time: DateTime<Local>,
    pub sysmon_events: Vec<SysmonEvent>,
    pub created_files: HashMap<String, String>,
}

#[derive(Serialize, Deserialize, Debug)]
struct Sample {
    pub id: String,
    pub execution_logs: Vec<ExecutionLog>,
}

pub struct LogManager {
    collection: Collection<Sample>,
}

impl LogManager {
    pub async fn init() -> Result<LogManager> {
        info!("Connecting mongodb...");
        let uri = "mongodb://localhost:27017";
        let mut client_options = ClientOptions::parse(uri).await?;

        let server_api = ServerApi::builder().version(ServerApiVersion::V1).build();
        client_options.server_api = Some(server_api);

        let client = Client::with_options(client_options)?;
        let collection = client
            .database("malware-analysis")
            .collection::<Sample>("log");

        Ok(LogManager { collection })
    }

    async fn get(&self, id: &str) -> Result<Option<Sample>> {
        Ok(self.collection.find_one(doc! {"id": &id}, None).await?)
    }

    async fn delete(&self, id: &str) -> Result<()> {
        self.collection.delete_one(doc! {"id": &id}, None).await?;
        Ok(())
    }

    pub async fn is_exist(&self, id: &str) -> Result<bool> {
        match self.get(id).await? {
            Some(_) => Ok(true),
            None => Ok(false),
        }
    }

    pub async fn store_execution_log(&self, id: String, execution_log: ExecutionLog) -> Result<()> {
        let old_execution_logs = self.get(&id).await?;

        let sample;
        match old_execution_logs {
            Some(mut logs) => {
                self.delete(&id).await?;
                logs.execution_logs.push(execution_log);
                sample = Sample {
                    id,
                    execution_logs: logs.execution_logs,
                };
            }
            None => {
                sample = Sample {
                    id,
                    execution_logs: vec![execution_log],
                };
            }
        }

        self.collection.insert_one(sample, None).await?;

        Ok(())
    }
}
