use std::collections::HashMap;
use std::fs::{create_dir_all, File};
use std::io::{BufRead, BufReader};

use anyhow::{Context, Result};
use chrono::Local;
use log::{info, warn};
use regex::Regex;
use tokio::time::{timeout, Duration};
use uuid::Uuid;

use crate::analysis_result::ExecutionLog;
use crate::sysmon_event::{SysmonEvent, SysmonEventId};
use crate::vm::Vm;

pub struct Sandbox {
    vm: Vm,
}

impl Sandbox {
    pub async fn init() -> Result<Self> {
        info!("Initializing sandbox...");
        let vm_name = "sandbox-".to_string() + &Uuid::new_v4().to_string();

        info!("Creating vm {}...", vm_name);
        let vm = Vm::create(&vm_name, "sandbox").await?;

        Ok(Self { vm })
    }

    pub async fn exec(&self, id: &str, sample_path: &str, limit_time: u64) -> Result<ExecutionLog> {
        let execution_id = Uuid::new_v4().to_string();
        let artifact_dir = format!("analysis_result/{}/artifact/{}", id, execution_id);
        create_dir_all(&artifact_dir)?;

        info!("Pushing sysmon config file...");
        self.vm.push_file("config.xml", "/root/config.xml").await?;

        info!("Pushing sample...");
        self.vm
            .push_file(sample_path, "/home/ubuntu/sample")
            .await?;
        self.vm
            .exec(&["sudo", "-u", "ubuntu", "chmod", "+x", "/home/ubuntu/sample"])
            .await?;

        info!("Starting sysmon...");
        self.vm
            .exec(&["sysmon", "-accepteula", "-i", "/root/config.xml"])
            .await?;

        info!("Executing sample...");
        match timeout(
            Duration::from_secs(limit_time),
            self.vm
                .exec(&["sudo", "-u", "ubuntu", "/home/ubuntu/sample"]),
        )
        .await
        {
            Err(_) => warn!(
                "Target program was forcefully terminated because it didn't finish within {}s",
                limit_time
            ),
            Ok(_) => info!("Finished"),
        }

        info!("Pulling syslog...");
        let syslog_path = format!("{}/syslog", &artifact_dir);
        self.vm.pull_file("/var/log/syslog", &syslog_path).await?;

        info!("Parsing syslog...");
        let syslog = File::open(syslog_path)?;
        let re = Regex::new(r"[A-Z][a-z]{2}\s+\d+\s\d\d:\d\d:\d\d\s\S+\ssysmon\S*:\s(.+)").unwrap();

        let mut created_files = HashMap::new();
        let mut sysmon_events = Vec::new();
        for l in BufReader::new(syslog).lines() {
            if let Some(c) = re.captures(&l?) {
                if let Ok(event) = SysmonEvent::from_xml(&c[1]) {
                    if event.event_id == SysmonEventId::FILE_CREATE {
                        let file_name = event
                            .event_data
                            .get("TargetFilename")
                            .context("No TargetFilename attribute")?;
                        if !created_files.contains_key(file_name) {
                            created_files.insert(file_name.to_string(), Uuid::new_v4().to_string());
                        }
                    }

                    sysmon_events.push(event);
                }
            };
        }

        info!("Pulling created files...");
        for f in &created_files {
            if let Err(e) = self
                .vm
                .pull_file(f.0, format!("{}/{}", &artifact_dir, f.1))
                .await
            {
                warn!("Failed to pull '{}': {}", f.0, e);
            }
        }

        Ok(ExecutionLog {
            id: execution_id,
            time: Local::now(),
            sysmon_events,
            created_files,
        })
    }
}
