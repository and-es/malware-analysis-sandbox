mod rule;

use anyhow::Result;
use itertools::Itertools;
use regex::Regex;

use crate::{
    analyzer::behavior_detection::rule::Rule,
    sysmon_event::{SysmonEvent, SysmonEventId},
};
use rule::{Filter, Rules, Sequential, Single};

const TRUSTED_DOMAINS: &[&str] = &["ipa.go.jp", "mozilla.org"];

pub fn detect(events: Vec<SysmonEvent>) -> Result<Vec<SysmonEvent>> {
    let mut rules = Rules::new();
    let mut rules_with_ppid = Rules::new();

    // test.sh
    rules.add(Single {
        filter: Filter {
            event_id: SysmonEventId::FILE_CREATE,
            condition: |e| {
                e.event_data
                    .get("TargetFilename")
                    .unwrap()
                    .contains("hello")
            },
        },
    });

    let events_ppid = events.clone().into_iter().into_group_map_by(|e| {
        e.event_data
            .get("ParentProcessId")
            .map(String::from)
            .unwrap_or("no ppid".to_string())
    });

    // download from untrusted domain and exec it
    rules_with_ppid.add(Sequential {
        filters: vec![
            Filter {
                event_id: SysmonEventId::PROCESS_CREATE,
                condition: |e| {
                    let cmd = e.event_data.get("CommandLine").unwrap();
                    if cmd.contains("wget") || cmd.contains("curl") {
                        let mut trusted = false;
                        for td in TRUSTED_DOMAINS {
                            let re = Regex::new(&format!(r"https://(.*\.)?{}(/|\s)", td)).unwrap();
                            if re.is_match(cmd) {
                                trusted = true;
                            }
                        }
                        if !trusted {
                            return true;
                        }
                    }
                    false
                },
            },
            Filter {
                event_id: SysmonEventId::PROCESS_CREATE,
                condition: |e| e.event_data.get("Image").unwrap().contains("chmod"),
            },
            Filter {
                event_id: SysmonEventId::PROCESS_CREATE,
                condition: |_| true,
            },
        ],
    });

    struct DeleteExistingFile {}

    impl Rule for DeleteExistingFile {
        fn first_match(&self, events: &Vec<SysmonEvent>) -> Vec<usize> {
            let mut result = Vec::new();
            let delete = Filter {
                event_id: SysmonEventId::FILE_DELETE,
                condition: |_| true,
            };

            for (i, event) in events.iter().enumerate() {
                if delete.is_match(event)
                    && event.event_data.get("Image").unwrap() != "/opt/sysmon/sysmon"
                {
                    let mut created = false;
                    for e in &events[..i] {
                        if e.event_id == SysmonEventId::FILE_CREATE
                            && e.event_data.get("TargetFilename").unwrap()
                                == event.event_data.get("TargetFilename").unwrap()
                        {
                            created = true;
                            break;
                        }
                    }
                    if !created {
                        result.push(i);
                    }
                }
            }

            result
        }
    }

    // delete file which was not created in execution
    rules.add(DeleteExistingFile {});

    rules.add(Single {
        filter: Filter {
            event_id: SysmonEventId::FILE_DELETE,
            condition: |e| {
                e.event_data
                    .get("TargetFilename")
                    .unwrap()
                    .contains("/var/log")
            },
        },
    });

    // delete file in /var/log
    rules.add(Single {
        filter: Filter {
            event_id: SysmonEventId::PROCESS_CREATE,
            condition: |e| {
                e.event_data.get("Image").unwrap() == "/usr/bin/rm"
                    && e.event_data
                        .get("CommandLine")
                        .unwrap()
                        .contains("/var/log")
            },
        },
    });

    // try to delete file in /var/log
    let mut result = Vec::new();
    let index = rules.match_all(&events);
    for i in index {
        result.push(events[i].clone());
    }
    for (_, e) in events_ppid {
        let index = rules_with_ppid.match_all(&e);
        for i in index {
            result.push(e[i].clone());
        }
    }

    Ok(result)
}
