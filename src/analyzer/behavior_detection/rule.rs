use crate::sysmon_event::{SysmonEvent, SysmonEventId};

pub struct Rules {
    rules: Vec<Box<dyn Rule>>,
}

impl Rules {
    pub fn new() -> Self {
        Self { rules: Vec::new() }
    }

    pub fn add<T: Rule + 'static>(&mut self, rule: T) {
        self.rules.push(Box::new(rule));
    }

    pub fn match_all(&self, events: &Vec<SysmonEvent>) -> Vec<usize> {
        let mut result = Vec::new();
        for rule in &self.rules {
            result.extend(rule.first_match(events));
        }
        result
    }
}

pub trait Rule {
    fn first_match(&self, events: &Vec<SysmonEvent>) -> Vec<usize>;
}

pub struct Filter {
    pub event_id: SysmonEventId,
    pub condition: fn(&SysmonEvent) -> bool,
}

impl Filter {
    fn is_match(&self, event: &SysmonEvent) -> bool {
        event.event_id == self.event_id && (self.condition)(event)
    }
}

pub struct Single {
    pub filter: Filter,
}

impl Rule for Single {
    fn first_match(&self, events: &Vec<SysmonEvent>) -> Vec<usize> {
        let mut result = Vec::new();
        for (i, event) in events.iter().enumerate() {
            if self.filter.is_match(&event) {
                result.push(i);
                return result;
            }
        }
        result
    }
}

pub struct Order {
    pub filters: Vec<Filter>,
}

impl Rule for Order {
    fn first_match(&self, events: &Vec<SysmonEvent>) -> Vec<usize> {
        let mut result = Vec::new();
        let filter_len = self.filters.len();
        if filter_len == 0 {
            return result;
        }

        let mut filter_idx = 0;
        for (i, event) in events.iter().enumerate() {
            if self.filters[filter_idx].is_match(&event) {
                result.push(i);
                filter_idx += 1;
            } else if filter_idx > 0 && self.filters[filter_idx - 1].is_match(&event) {
                result.push(i);
            } else if self.filters[0].is_match(&event) {
                result.clear();
                filter_idx = 0;
            }

            if filter_idx == filter_len {
                return result;
            }
        }

        Vec::new()
    }
}

pub struct Sequential {
    pub filters: Vec<Filter>,
}

impl Rule for Sequential {
    fn first_match(&self, events: &Vec<SysmonEvent>) -> Vec<usize> {
        let mut result = Vec::new();
        let filter_len = self.filters.len();
        if filter_len == 0 {
            return result;
        }

        let mut filter_idx = 0;
        for (i, event) in events.iter().enumerate() {
            if self.filters[filter_idx].is_match(&event) {
                result.push(i);
                filter_idx += 1;
            } else if self.filters[0].is_match(&event) {
                result.clear();
                result.push(i);
                filter_idx = 1;
            } else {
                result.clear();
                filter_idx = 0;
            }

            if filter_idx == filter_len {
                return result;
            }
        }

        Vec::new()
    }
}
